# -*- coding: utf-8 -*-
"""Tarea2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zEfl6mGY9a_50eomyQK9QfZfhP2efe5E

# **Problemas Computacionales**

**Integrantes:**  

*   Gallardo Rosales Sofía
*   Salgado Islas Sergio

17. Dado el sistema $A x=b$ :

(a) Resolver con eliminación Gaussiana para
$$
A=\left[\begin{array}{ccc}
2 & 4 & -2 \\
4 & 9 & -3 \\
-2 & -1 & 7
\end{array}\right] ; \quad b=\left[\begin{array}{c}
2 \\
8 \\
10
\end{array}\right]
$$
"""

def elimina_gauss(A, b):
    n = len(b) #Número de filas de b
    U = np.copy(A)
    y = np.copy(b)

    # Transformaremos A en una matriz triangular superior
    for i in range(n - 1):
        for j in range(i + 1, n): # Hacer ceros debajo del pivote en la columna i
            factor = U[j, i] / U[i, i] # Calcula el factor por el cual se multiplicara para hacer cero debajo del pivote
            U[j, i:] -= factor * U[i, i:] # Resta la fila del pivote
            y[j] -= factor * y[i]

    # Resolveremos el sistema triangular
    x = np.zeros(n) # Definimos el vector de solución
    for i in range(n - 1, -1, -1):
        x[i] = (y[i] - np.dot(U[i, i+1:], x[i+1:])) / U[i, i] # Calcula el producto escalar entre los coeficientes
                                                                        # y las soluciones ya encontrads
    return x

# Definimos la matriz A y vector b, de nuestro problema dado
A = np.array([[2, 4, -2],
              [4, 9, -3],
              [-2, -1, 7]], dtype=float)
b = np.array([2, 8, 10], dtype=float)

# Resolveremos el sistema con el metodo aneriormente construido
x = elimina_gauss(A, b)
x

"""(b) Usar Factorización LU de $A$ para resolver el sistema $A y=c$, donde:
$$
c=\left[\begin{array}{c}
4 \\
8 \\
-6
\end{array}\right]
$$

"""

import numpy as np

def factorizacion_lu(A):
    n = A.shape[0] # Número de filas y columnas en A
    U = np.copy(A) # Copiamos A en U, para transformarla en U
    L = np.eye(n)  # Inicializamos la Matriz L con la matriz identidad
    P = np.eye(n)  # De igual forma para P
    Ps = []  # Lista para guardar las matrices de permutación
    Ls = []  # Lista para guardar las inversas de las matrices L elementales

    # Proceso de factorización LU con pivoteo parcial
    for k in range(n):
        max_index = np.argmax(np.abs(U[k:, k])) + k  # Encontramos el indice del mayor valor absoluto en la columa k desde la fila k
        # Intercambiamos las filas en U y P
        if k != max_index:
            U[[k, max_index], :] = U[[max_index, k], :]  # Intercambiar filas en U con las filas del mayor valor absoluto
            P[[k, max_index], :] = P[[max_index, k], :]  # Lo mismo para P

        # Guarda la matriz de permutación de esta iteración
        Ps.append(P.copy())

        # Modifica las filas debajo de la fila k en U y actualiza L
        for i in range(k+1, n):
            factor = U[i, k] / U[k, k] # Calcula el factor por el cual se multiplicara para hacer cero debajo del pivote
            U[i, k:] -= factor * U[k, k:] # Resta la fila del pivote
            L[i, k] = factor # Actualizar matriz L en la posición i, k

        # Guarda la inversa de L de esta iteración (sólo se altera la columna k)
        L_inv = np.eye(n)
        L_inv[k+1:, k] = -L[k+1:, k]
        Ls.append(L_inv)

    return L, U, Ps, Ls

def resolver_sistema(L, U, c):
    # Resolveremos el sistema triangular inferior
    y = np.zeros_like(c) # Definimos el vector de solución
    for i in range(len(c)):
        y[i] = (c[i] - np.dot(L[i, :i], y[:i])) / L[i, i]

    # Resolveremos el sistema triangular superior
    x = np.zeros_like(c) # Definimos el vector de solución
    for i in range(len(c)-1, -1, -1):
        x[i] = (y[i] - np.dot(U[i, i+1:], x[i+1:])) / U[i, i]

    return x

# Definimos la matriz A y vector c, de nuestro problema dado
A = np.array([[1, 2, 2], [4, 4, 2], [4, 6, 4]], dtype=float)
c = np.array([4, 8, -6], dtype=float)

# Realizamos la Factorización LU con el metodo anteriormente construido
L, U, Ps, Ls = factorizacion_lu(A)

# Resolveremos el sistema con el metodo aneriormente construido
x = resolver_sistema(L, U, c)

# Mostrar los resultados
print("Matriz L:")
print(L)
print("Matriz U:")
print(U)
print("Solución x:")
print(x)

"""18. Sean $A$ y $b$ dados como sigue:

(a)
$$
A=\left[\begin{array}{ccc}
4 & -1 & 3 \\
-8 & 4 & -7 \\
12 & 1 & 8
\end{array}\right] ; \quad \bar{b}=\left[\begin{array}{c}
-8 \\
19 \\
-19
\end{array}\right]
$$

 Resolver el sistema $A \bar{x}=\bar{b}$ con las rutinas:
- Factorización $L U$.
- Factorización $L U$ con pivoteo parcial.
- Factorización $L U$ con pivoteo total.



"""

import numpy as np

def LU_sinPivote(A):
    n = A.shape[0] # Número de filas/columnas de A
    U = np.copy(A) # Copiamos A en U, para transformarla en U
    L = np.eye(n) # Inicializamos la Matriz L con la matriz identidad

    # Proceso para convertir A en L y U
    for j in range(n-1):
        for i in range(j+1, n):
            L[i, j] = U[i, j] / U[j, j] # Calcula el factor por el cual se multiplicara para hacer cero debajo del pivote
            U[i, j:] -= L[i, j] * U[j, j:] # Resta la fila del pivote

    return L, U

def resolver_LU(L, U, b):
    n = len(b)  #Número de filas de b
    y = np.zeros(n) # Definimos el vector de solución
    x = np.zeros(n)

    #  Resolveremos el sistema triangular inferior
    for i in range(n):
        y[i] = b[i] - np.dot(L[i, :i], y[:i])

    # Resolveremos el sistema triangular superior
    for i in range(n-1, -1, -1):
        x[i] = (y[i] - np.dot(U[i, i+1:], x[i+1:])) / U[i, i]

    return x

def LU_parcialPivote(A):
    U = np.copy(A) # Copiamos A para la transformación
    n = U.shape[0] # Tamaño de la matriz U
    Ps = []  # Lista para almacenar las matrices de permutación
    Ls = [] # PAra almacenar las inversas de L

   # Proceso de factorización LU con pivoteo parcial, visto en clase
    for j in range(n):
        P = np.eye(n) # Inicializamos la matriz de permutacion
        L = np.eye(n) # Inicializamos L, donde aambos son la identidad
        k = np.argmax(np.abs(U[j:, j])) + j # Encuentra el índice del mayor valor en la columna j
        U[[j, k]] = U[[k, j]]  # Intercambia filas en U
        P[[j, k]] = P[[k, j]]  # Actualiza la matriz de permutación
        for i in range(j+1, n):
            L[i, j] = -U[i, j] / U[j, j] # Calcula el factor por el cual se multiplicara para hacer cero debajo del pivote
        U = L @ U # Actualiza U multiplicando por L
        Ps.append(P) # Guardamos P
        Ls.append(np.linalg.inv(L)) # Guardamos la inversa de L

    # Combinamos las permutaciones y L's para obtener la matriz PM
    PM = np.eye(n) # Inicializamos la matriz
    for i in range(len(Ps) - 1, -1, -1):
        PM = (Ps[i] @ Ls[i]) @ PM # Hacemos las mutiplicaciones y actualizamos

    return PM, U

def LU_totalPivote(A):
    n = A.shape[0] # Tamaño de la matriz A
    U = np.copy(A) # Copiamos A para la transformación
    P = np.eye(n) # Inicializamos la matriz de permutacion de filas
    Q = np.eye(n) # Inicializamos la matriz de permutacion de columnas

    # Proceso de factorización con pivoteo total
    for j in range(n):
        max_index = np.unravel_index(np.argmax(np.abs(U[j:, j:])), U[j:, j:].shape) # Buscar el mayor valor en la submatriz restante
        max_index = (max_index[0] + j, max_index[1] + j) # Encuentra el índice del mayor valor en la columna j
        # Intercambia las filas y columnas según el mayor valor
        U[[j, max_index[0]], :] = U[[max_index[0], j], :]
        U[:, [j, max_index[1]]] = U[:, [max_index[1], j]]
        P[[j, max_index[0]], :] = P[[max_index[0], j], :]
        Q[:, [j, max_index[1]]] = Q[:, [max_index[1], j]]

        # Eliminamos los elementos debajo del pivote
        for i in range(j+1, n):
            factor = U[i, j] / U[j, j] # Calcula el factor por el cual se multiplicara para hacer cero debajo del pivote
            U[i, j:] -= factor * U[j, j:] # Resta la fila del pivote
            U[i, j] = factor

    return P, U, Q

# Definimos la matriz A y vector b, de nuestro problema dado
A = np.array([[4, -1, 3], [-8, 4, -7], [12, 1, 8]], dtype=float)
b = np.array([-8, 19, -19], dtype=float)

print("Sea A = ", A)
print( "y b = ", b)

# REsolvemos el sistema utilizando LU sin pivoteo
L, U = LU_sinPivote(A)
x = resolver_LU(L, U, b)
print("\nSolucion de x sin pivoteo:")
print("\nL = ",L)
print("\nU = ", U)
print("\nx = ", x)

# Resolvemos el sistema utilizando LU con pivoteo parcial
L, U = LU_parcialPivote(A)
x = resolver_LU(L, U, b)
print("\nSolucion de x con pivoteo parcial:")
print("\nL = ",L)
print("\nU = ", U)
print("\nx = ", x)

# Resolvemos el sistema utilizando LU con pivoteo total
P, U, Q = LU_totalPivote(A)
y = resolver_LU(P, U, b)
x = Q @ y  # Aplicar permutación Q a la solución
print("Solucion de x con pivoteo total:")
print("\nP = ", P)
print("\nU = ", U)
print("\nx = ", x)

"""(b)
$$
A=\left[\begin{array}{cccc}
1 & 4 & -2 & 1 \\
-2 & -4 & -3 & 1 \\
1 & 16 & -17 & 9 \\
2 & 4 & -9 & -3
\end{array}\right] ; \quad \bar{b}=\left[\begin{array}{c}
3.5 \\
-2.5 \\
15 \\
10.5
\end{array}\right]
$$

Resolver cada sistema $A \bar{x}=\bar{b}$ con las rutinas:
- Factorización $L U$.
- Factorización $L U$ con pivoteo parcial.
- Factorización $L U$ con pivoteo total.


"""

# Definimos la matriz A y vector b, de nuestro problema dado
A = np.array([[1, 4, -2, 1], [-2, -4, -3, 1], [1, 16, -17, 9], [2, 4, -9, -3]], dtype=float)
b = np.array([3.5, -2.5, 15, 10.5], dtype=float)

print("Sea A = ", A)
print( "y b = ", b)

# REsolvemos el sistema utilizando LU sin pivoteo
L, U = LU_sinPivote(A)
x = resolver_LU(L, U, b)
print("\nSolucion de x sin pivoteo:")
print("\nL = ",L)
print("\nU = ", U)
print("\nx = ", x)

# Resolvemos el sistema utilizando LU con pivoteo parcial
L, U = LU_parcialPivote(A)
x = resolver_LU(L, U, b)
print("\nSolucion de x con pivoteo parcial:")
print("\nL = ",L)
print("\nU = ", U)
print("\nx = ", x)

# Resolvemos el sistema utilizando LU con pivoteo total
P, U, Q = LU_totalPivote(A)
y = resolver_LU(P, U, b)
x = Q @ y  # Aplicar permutación Q a la solución
print("Solucion de x con pivoteo total:")
print("\nP = ", P)
print("\nU = ", U)
print("\nx = ", x)

"""(c)
$$
A=\left[\begin{array}{ccccc}
4 & 5 & -1 & 2 & 3 \\
12 & 13 & 0 & 10 & 3 \\
-8 & -8 & 5 & -11 & 4 \\
16 & 18 & -7 & 20 & 4 \\
-4 & -9 & 31 & -31 & -1
\end{array}\right] ; \quad \bar{b}=\left[\begin{array}{c}
34 \\
93 \\
-33 \\
131 \\
-58
\end{array}\right]
$$

Resolver cada sistema $A \bar{x}=\bar{b}$ con las rutinas:
- Factorización $L U$.
- Factorización $L U$ con pivoteo parcial.
- Factorización $L U$ con pivoteo total.

"""

# Definimos la matriz A y vector b, de nuestro problema dado
A = np.array([[4, 5, -1, 2, 3], [12, 13, 0, 10, 3], [-8, -8, 5, -11, 4], [16, 18, -7, 20, 4], [-4, -9, 31, -31, -1]], dtype=float)
b = np.array([34, 93, -33, 131, -58], dtype=float)

print("Sea A = ", A)
print( "y b = ", b)

# REsolvemos el sistema utilizando LU sin pivoteo
L, U = LU_sinPivote(A)
x = resolver_LU(L, U, b)
print("\nSolucion de x sin pivoteo:")
print("\nL = ",L)
print("\nU = ", U)
print("\nx = ", x)

# Resolvemos el sistema utilizando LU con pivoteo parcial
L, U = LU_parcialPivote(A)
x = resolver_LU(L, U, b)
print("\nSolucion de x con pivoteo parcial:")
print("\nL = ",L)
print("\nU = ", U)
print("\nx = ", x)

# Resolvemos el sistema utilizando LU con pivoteo total
P, U, Q = LU_totalPivote(A)
y = resolver_LU(P, U, b)
x = Q @ y  # Aplicar permutación Q a la solución
print("Solucion de x con pivoteo total:")
print("\nP = ", P)
print("\nU = ", U)
print("\nx = ", x)

"""19. Dada la matriz
$$
A=\left(\begin{array}{ccccc}
1 & 0 & 0 & 0 & 1 \\
-1 & 1 & 0 & 0 & 1 \\
-1 & -1 & 1 & 0 & 1 \\
-1 & -1 & -1 & 1 & 1 \\
-1 & -1 & -1 & -1 & 1
\end{array}\right)
$$

(a) ¿Qué sucede cuando se usa Eliminación Gaussina con pivoteo parcial?

(b) Usar Eliminación Gaussina con pivoteo parcial para resolver sistemas de varios tamaños (al menos 5) con vectores $b$ elegidos por cualquier criterio. Describir como se comporta la condición de la matriz.

(c) Escribir una rutina que factorice la matriz $(L U)$ con pivoteo total.

"""

A = np.array([
    [1, 0, 0, 0, 1],
    [-1, 1, 0, 0, 1],
    [-1, -1, 1, 0, 1],
    [-1, -1, -1, 1, 1],
    [-1, -1, -1, -1, 1]
], dtype=float)

L, U = LU_parcialPivote(A)
print("L:")
print(L)
print("U:")
print(U)

"""El pivoteo parcial no cambiara la matriz significativamente, ya que la eliminación gaussina xon pivoteo parcial seleccionará el elemento más grande en la coolumna actual como pivote en términos del valor absoluto, que en esta matriz seria 1 o -1, que son iguales al aplicar el valor absoluto."""

def resuelv_LU(L, U, b):
    # Sustitución hacia adelante: Ly = b
    y = np.linalg.solve(L, b)
    # Sustitución hacia atrás: Ux = y
    x = np.linalg.solve(U, y)
    return x

# Creación de varios vectores b, para resolver los temas
sizes = [5, 10, 15, 20, 25]  # Diferentes tamaños para b
resul = []
for size in sizes:
    A = np.random.rand(size, size)  # Matriz A más grande para probar
    b = np.random.rand(size)        # Vector b aleatorio
    L, U = LU_parcialPivote(A)
    x = resuelv_LU(L, U, b)
    Cond_numero = np.linalg.cond(A)
    resul.append((size, Cond_numero))

for size, cond in resul:
    print(f"Tamaño: {size}, Cond_numero: {cond}")

"""La condicion será mayor a medida que el tamaño de la matriz aumente porque se acumulan más elementos negativos."""

P, U, Q = LU_totalPivote(A)
print("P:")
print(P)
print("U:")
print(U)
print("Q:")
print(Q)

"""20. Usar Eliminación Gaussiana sin pivoteo para resolver el sistema:
$$
\left[\begin{array}{ll}
\epsilon & 1 \\
1 & 1
\end{array}\right]\left[\begin{array}{l}
x_1 \\
x_2
\end{array}\right]=\left[\begin{array}{c}
1+\epsilon \\
2
\end{array}\right]
$$
para $\epsilon=10^{-2 k}$, con $k=1, \cdots, 10$. La solución exacta es $x=\left[\begin{array}{ll}1 & 1\end{array}\right]^T$, ¿cómo se comporta la solución conforme $\epsilon$ decrece?

"""

# Rango de valores de k para evaluar epsilon
k_v = range(1, 11)

# Resultados
Resultados = []

for k in k_v:
    epsilon = 10 ** (-2 * k)
    A = np.array([[epsilon, 1], [1, 1]], dtype=float)
    b = np.array([1 + epsilon, 2], dtype=float)
    x = elimina_gauss(A, b)
    Resultados.append((epsilon, x))

# Mostra los resultados
for epsilon, x in Resultados:
    print(f"epsilon = {epsilon:.2e}, solution x = {x}")

"""Debido a los problemas de estabilidad numérica que ocurren cuando $\epsilon$  es muy pequeño (especialmente en el pivote), esperamos ver desviaciones en la solución calculada. La pérdida de precisión numérica será más evidente a medida que el valor de $\epsilon$ disminuye debido a los errores de redondeo y cancelación."""